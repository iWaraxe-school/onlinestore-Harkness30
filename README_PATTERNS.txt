В системе было имплементировано 3 вида паттернов проектирования:
- Chain of Responsibilities
- Builder
- Singleton

Chain of Responsibilities
   был реализован путем создания пакета Handlers содержащего абстрактный класс OrderHandler.java и его наследники,
    обрабатывающие комманды пользователя.
    использование абстрактного класса, но не интерфейса обусловлено необходимостью хранить поля, которые используются почти каждым наследником.
    Все наследники связаны (хранят ссылки на следующий) и каждый отвечает за обработку только одной из возможных команд пользователя,
    а иные передает далее по цепочке.
    Цепочка обработчиков имплементирована в Main(), а команда передается в виде объекта Order, который хранит список продуктов и.

Полученные преимущества:
-      так как за обработку каждой команды отвечает отдельный обект, это облегчает дальнейший рефакторинг.
    Например, когда будет добавлено взаимодействие с БД.
-      добавление новых команд не затронет имеющийся функционал
Недостатков не вижу.


Builder
    реализован в классе ProductBuilder, берет на себя создание экземпляра Product.
    Значительных преимуществ не дает. Разве что, при ручном создании объекта,
    поля можно удобно инициализировать цепочкой вызванных методов.
    В конкретном случае структура создаваемых объектов простая,
    поэтому основные преимущества паттерна не работают.
недостатки:
- теоретически из-за отсутствия конструктора некоторые поля могут остаться со
значениями по умолчанию (если по каким-то причинам не будут проиниализированы).
установить ограничения возможно только для поля Name, т.к. Rate и Price в теории могут иметь и значения 0 / 0.0


Singleton
    объекты  категорий и самого магазина могут существовать только в 1 экземпляре.
    для этого в классах категорий Bike, Milk, Phone, и в самом классе Store возможность создания экземпляра
    предусмотрена только через статик метод getInstance(). Сам метод помечен ключевым словом synchronized
    чтобы в дальнейшем не мешать работе потоков.

Преимущества:
-   исключены проблемы, из-за потенциального появления второго экземпляра отного из классов.
    работаем только с одним экземпляром и его состоянием

Недостатки:
    на данном этапе нет. В дальнейшем с введением многопоточности время исполнения может незначительно увеличиваться
    из-за синхронизированных методов